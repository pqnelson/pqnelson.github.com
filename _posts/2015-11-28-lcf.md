---
layout: post
title: Notes on LCF Tactics
published: true
quote: "All men can see these tactics whereby I conquer, but what none can see is the strategy out of which victory is evolved."
quoteSource: Sun Tzu, <i>Art of War</i>
tags: [Automated Theorem Prover, Logic]
---

# Basic Structure of LCF Tactics

## Prose Description

Working in first-order logic, we have propositions we'd like to
prove. When proven, they're promoted to _theorems_. For the most part we
can think of propositions as just some _logical formula_.

We want to prove only true statements, it'd be a catastrophe if we
somehow allowed false statements into the system. So we should have a
type `thm` to indicate that the proposition is _proven_ true.

A proof for a theorem then amounts to mapping the premises to the
conclusion. That is, a function in the metalanguage expecting a list of
`thm`, and will produce a `thm`. (We can compose proofs, at least in
theory, the same way we compose functions.) For this case, the proof is
"forced" to prove only true statements...provided the rules of inference
are sound.

But...How do we get from an unproven formula to a theorem?

The basic structure of the formula we will be proving is something of
the form: _p_<sub>1</sub> ∧ ... ∧ _p_<sub><i>n</i></sub> ⇒ _q_. Solving
such a goal produces a theorem "⊢ _p_<sub>1</sub> ∧ ... ∧ _p_<sub><i>n</i></sub> ⇒ _q_."

We would therefore like to transform one goal into a list of subgoals,
equipped with a _justification function_ which (given theorems solving
each subgoal) produces a theorem solving the original goal we started with.

Observe that there's a recursive structure here: to solve a goal, we
simply transform it into several sub-goals, then solve the
sub-goals. What transformations permit such things?

_Tactics_ transform a set of goals plus their justification function, to
another set of goals plus a modified justification function. Why do
this?

Well, the basic notion is to set up the goal we'd like to prove, then
refine the goal using tactics until the list of subgoals is empty. The
justification function is modified on each step, working with fewer and
fewer subgoal inputs. The final justification function accepts an empty
list, and produces the desired formula embodied in a theorem.

## Pseudo-Code Implementation

The basic scheme, in pidgin Haskell, is we have logical formulas we'd
like to prove. Once proven, they are promoted to logical theorems. We
have

```haskell
formula :: string --- implementation not important for the moment
thm :: formula
proof :: [thm] -> thm
```

But we have more! In general, if we are trying to prove a formula, then
we have a _goal_ we'd like to prove. Sometimes it's easier to break it
up into smaller "sub-goals", and prove each case. To handle this case,
we want our goal to be a list of formulas.

```haskell
goal :: ([formula], formula, proof)

justify :: goal -> proof
justify (_, _, pf) = pf

consequent :: goal -> formula
consequent (_, fm, _) = fm

hypotheses :: goal -> [formula]
hypotheses (fms, _, _) = fms
```

Now, the _pièce de résistance_ of the LCF system: tactics. A tactic
transforms a goal into a list of goals, plus their proofs.

```haskell
tactic :: [goal] -> [goal]
```

Sometimes people make the `goal :: ([formula], formula)` and stick the
`proof` into the `tactic`.

**Observation 1: Inference is Sound.**
Perhaps this is the greatest strength of the LCF approach, it is trivial
to prove the inference rules are sound.

**Observation 2: Custom Tactics.**
Since a tactic is "just" a function, we can write our own custom
tactics! This allows us to extend the theorem prover quite a bit for our
own needs.

# Modern Developments

## Custom Tactics

One of the disadvantages of writing our own custom tactics is...we have
to recompile the entire program from scratch. That's quite a bummer for
a sophisticated prover like Isabelle, since it can take a few minutes on
modern computers. (And a bit longer on, say, an 800MHz Pentium III machine.)

Coq has a beautiful solution: have tactics be _part_ of the user-defined
language. (Aside from a small core, that is.) In this manner, tactics
are like "macros" which are expanded later on.

## Declarative Proofs

One of the major disadvantages of the "vanilla" LCF system is the proofs
are unreadable by humans. For example:

```coq
Lemma canonical_forms_bool : ∀t,
  empty ⊢ t ∈ TBool →
  value t →
  (t = ttrue) ∨ (t = tfalse).
Proof.
  intros t HT HVal.
  inversion HVal; intros; subst; try inversion HT; auto.
Qed.

Lemma canonical_forms_fun : ∀t T1 T2,
  empty ⊢ t ∈ (TArrow T1 T2) →
  value t →
  ∃x u, t = tabs x T1 u.
Proof.
  intros t T1 T2 HT HVal.
  inversion HVal; intros; subst; try inversion HT; subst; auto.
  ∃x0. ∃t0. auto.
Qed.
```

The alternative style for automated provers is _declarative
proofs_. This more closely resembles how mathematicians write a
proof. For example:

```
theorem Th2:
 ex x, y st x is irrational & y is irrational &
  x.^.y is rational
proof
 set w = sqrt 2;
A1: w is irrational by INT_2:44,Th1;
 w>0 by AXIOMS:22,SQUARE_1:84;
 then
A2: (w.^.w).^.w = w.^.(w * w) by POWER:38
  .= w.^.(w^2) by SQUARE_1:def 3
  .= w.^.2 by SQUARE_1:def 4
  .= w^2 by POWER:53
  .= 2 by SQUARE_1:def 4;
 per cases;
 suppose
A3: w.^.w is rational;
  take w, w;
  thus thesis by A1,A3;
 suppose
A4: w.^.w is irrational;
  take w.^.w, w;
  thus thesis by A1,A2,A4,RAT_1:7;
end;
```

We can get the best of both worlds by creating "declarative
tactics" (c.f., Harrison's
[paper](http://www.cl.cam.ac.uk/~jrh13/papers/mizar.html) and
Wiedijk's [paper](https://www.cs.ru.nl/~freek/mizar/miz.pdf)).

# Conclusion

So, we've introduced the basic idea behind LCF, specifically tactics and
goals. Its soundness is quite simple to prove (it's a "Look!" type
proof).

We've looked at one pseudo-specification in pidgin Haskell, discussed
recent developments, and undoubtedly have missed quite a few recent
developments and open research projects.

# References

- John Harrison,
  _Handbook of Practical Logic and Automated Reasoning_.
  Cambridge University Press, 2009. See chapter 6 especially.
- John Sterling,
  [Modernized LCF](http://www.jonmsterling.com/posts/2015-07-03-modernized-lcf-the-logic-of-goals-and-tactics.html)
- Andrea Asperti's talk [A New Type For Tactics](http://www-sop.inria.fr/members/Enrico.Tassi/plmms09-slides.pdf) at PLLMS 2009.
  - Andrea Asperti, Wilmer Ricciotti, Claudio Sacerdoti, Coen Enrico Tassi,
    [A new type for tactics](http://matita.cs.unibo.it/PAPERS/plmms09.pdf).
- CStheory.stackexchange thread [How do 'tactics' work in proof assistants?](http://cstheory.stackexchange.com/q/5696) 
- Lawrence Paulson,
  [LCF + Logical Frameworks = Isabelle (25 Years  Later)](http://events.inf.ed.ac.uk/Milner2012/slides/Paulson/LCF+-without-transitions.pdf)
  Talk at Milner Symposium, 16 April 2012.

## Historical Documents
- Robin Milner,
  [Logic for Computable Functions: description of a machine implementation](http://oai.dtic.mil/oai/oai?verb=getRecord&metadataPrefix=html&identifier=AD0785072)
  (1972)
