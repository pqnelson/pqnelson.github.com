<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link rel="stylesheet" type="text/css" href="../../stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../../stylesheets/default.css" media="screen" />
    <title>Analysis of Algorithms</title>
  </head>
<body>
<article>
<header>
<h1>Analysis of Algorithms</h1>
</header>
<section>
<h2>Introduction</h2>
<p>
The key problem we try tackling is <em>running time</em>. This focus
dates back to Babbage (if not earlier, when computers were actual humans
computing difficult math problems by hand). Why analyze algorithms?
</p>
<ul>
<li>Predict performance (our primary interest)</li>
<li>Compare algorithms: we want some way to say, objectively, "This
  algorithm is better than that one"</li>
<li>Provide guarantees: we want some confidence the algorithm will work!</li>
<li>Understand theoretical basis</li>
</ul>
<p>
The most practical reason: avoid performance bugs.
</p>
<p>
For example, if we break down a wave from N samples into periodic
components ("discrete Fourier transform"). How to do it?
</p>
<p>
The brute force approach takes <code>O(N^2)</code> steps, but using the
fast Fourier transform we use <code>O(N log N)</code> steps.
</p>
<p>
The N-body problem has been a huge problem for over a hundred years (it
dates back to Laplace!). The naive approach requires <code>O(N^2)</code>
steps. 
</p>
<p>
The <a href="http://en.wikipedia.org/wiki/Barnes%E2%80%93Hut_simulation">Barnes-Hut Algorithm</a>
requires only <code>O(N log N)</code> steps, enabling new research!
</p>
<h3>Challenge</h3>
<p>
"Will my program be able to solve a large practical problem?"
</p>
<p>
Frequent frustrations: Why is my program so slow? Why does it run out of memory?
</p>
<p>
<b>Key insight:</b> Knuth suggested (in the 1970s) we should use the
scientific method to understand algorithm performance.
</p>
<p>
This requires setting up some model determining the
complexity, which gives some rough estimate of the runtime.
</p>
<p>
A different "scientific" approach: clock the running time for varying
inputs, then extrapolate some approximate running time function.
</p>
</section>
<section>
<h2>Observations</h2>
<p>
We will use one example throughout this section. We will try to solve
the <a href="http://en.wikipedia.org/wiki/3SUM">3-Sum Problem</a>: given N distinct integers, how many triples sum to
zero?
</p>
<p>
To be concrete about this, if we had <code>int[] n = [30, -40, -20, -10,
    40, 10, 5]</code>, we see (30, 10, -40) is one such triple. Why? Observe
30 + 10 + (-40) = 0.
</p>
<p>
If we wrote a program to solve this problem, the key function would be:
</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreeSum</span>
<span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">{</span>
    <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
	  <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
	    <span class="n">count</span><span class="o">++;</span>
    <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
  <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="n">In</span><span class="o">.</span><span class="na">readInts</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="n">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">count</span><span class="o">(</span><span class="n">a</span><span class="o">));</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>
How to estimate running time?
</p>
<p>
<b>Empirical Analysis.</b> We just give various input sizes, and measure
the running time.
</p>
<p>
We plot the running time <i>T(N)</i> against the input size <i>N</i>. 
</p>
<p>
If we assume some form of power law, <i>T(N)=aN<sup>b</sup></i>, then
plotting the log-log values would be more useful.
</p>
<p>
<b>Doubling Hypothesis.</b> The trick is to keep doubling the
input. Why?
Observe: <i>T</i>(2<i>N</i>)=<i>a</i>2<sup><i>b</i></sup><i>N</i>. Divide
this by <i>T(N)</i>, and you get 2<sup><i>b</i></sup>. Now take the <a href="http://en.wikipedia.org/wiki/Logarithm_of_the_base_2">lg()</a>
of this ratio, you get a value for <i>b</i>.
</p>
<p>
So, keep doubling <i>N</i>, and you get some estimate for <i>b</i>. 
</p>
<p>
<b>Experimental Algorithmics.</b> So, if we take into account the System
independent effects (e.g. algorithm, input data, etc.) and the System
dependent effects (hardware, software, OS, networking, etc.), we
observe: System independent effects determines <i>b</i>, and both
dependent and independent effects determine <i>a</i>.
</p>
<p>
<em>Bad News:</em> it's difficult to get precise measurements (e.g.,
running multiple programs skews accuracy, etc.).
</p>
<p>
<em>Good News:</em> the experiments are cheap, so we have a tolerable
approximation for practical purposes.
</p>
</section>
<section>
<h2>Mathematical Model</h2>
<p>
Donald Knuth popularized this approach starting in the 1960s. The basic
idea is: if we know the number of different operations used, the
frequency each operation is used, and the cost per operation, then we
may deduce the running time as:
</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mtext>Total run time</mtext>
  <mo>=</mo>
  <munder>
    <mo>&#x2211;<!-- ∑ --></mo>
    <mrow class="MJX-TeXAtom-ORD">
      <mtext>operations</mtext>
    </mrow>
  </munder>
  <mrow>
    <mo>(</mo>
    <mtext>cost of operation</mtext>
    <mo>)</mo>
  </mrow>
  <mrow>
    <mo>(</mo>
    <mtext>frequency of operation</mtext>
    <mo>)</mo>
  </mrow>
</math>
<p>
We need to analyze the program to determine the set of
operations. Sadly, the cost for each operation depends on the computer
(and, for non-assembly languages, the compiler). The frequency each
operation is used depends on the algorithm and input data.
</p>
<p>
<b>In principle</b>, accurate mathematical models are available. Knuth
explores this in his <em>Art of Computer Programming</em> monographs.
</p>
<h3>Example: 1-Sum Problem</h3>
<p>
Consider the problem where the sum of any 1 integer is zero. More
simply: we look for zero integers! The solution, in pseudocode:
</p>
<pre>
int count = 0;
for (int i = 0; i < N; i++)
    if (a[i] == 0)
        count++;
</pre>
<p>
We have:
<ul>
<li> 2 variable declarations and initializations;</li>
<li><code>N+1</code> integer comparisons;</li>
<li><code>N</code> equality comparisons;</li>
<li><code>N</code> array accesses; and</li>
<li><code>k</code> increment operations, where <code>N&le;k&le;2N</code>.</li>
</ul>
</p>
<h3>Example: 2-Sum Problem</h3>
<p>
Lets get a little more complicated, looking at a problem where the sum
of any two integers is zero. The solution in pseudocode:
</p>
<pre>
int count = 0;
for (int i = 0; i &lt; N; i++)
    for (int j = i; j &lt; N; j++)
        if ( a[i] + a[j] == 0)
            count++;
</pre>
<p>
Observe there
are <a href="http://en.wikipedia.org/wiki/Binomial_coefficient"><code>N</code>
    choose 2</a>
different comparison operations. More explicitly:
</p>
<ul>
<li><code>N+2</code> variable declarations and initializations;</li>
<li><code>(N+1)(N+2)/2</code> integer comparisons;</li>
<li><code>N(N-1)/2</code> equality comparisons;</li>
<li><code>N(N-1)/2</code> array accesses; and</li>
<li><code>k</code> increment operations, where <code>N(N-1)/2&le;k&le;N(N-1)</code>.</li>
</ul>
<h3>Tilde Notation</h3>
<p>
We use the tilde notation, which ignores lower order
terms. When <code>N</code> is large, the ignored terms are
negligible. When <code>N</code> is small, we don't care about them. So
lets look at some examples:
</p>
<p>
<b>Example:</b> <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mfrac>
    <mn>1</mn>
    <mn>6</mn>
  </mfrac>
  <msup>
    <mi>N</mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mn>3</mn>
    </mrow>
  </msup>
  <mo>+</mo>
  <mn>20</mn>
  <mi>N</mi>
  <mo>+</mo>
  <mn>16</mn>
  <mo>&#x223C;<!-- ∼ --></mo>
  <mfrac>
    <mn>1</mn>
    <mn>6</mn>
  </mfrac>
  <msup>
    <mi>N</mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mn>3</mn>
    </mrow>
  </msup>
</math>
</p>
<p>
<b>Example:</b>
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mfrac>
    <mn>1</mn>
    <mn>6</mn>
  </mfrac>
  <msup>
    <mi>N</mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mn>3</mn>
    </mrow>
  </msup>
  <mo>+</mo>
  <mn>100</mn>
  <mi>N</mi>
  <mo>+</mo>
  <mn>56</mn>
  <mo>&#x223C;<!-- ∼ --></mo>
  <mfrac>
    <mn>1</mn>
    <mn>6</mn>
  </mfrac>
  <msup>
    <mi>N</mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mn>3</mn>
    </mrow>
  </msup>
</math>
</p>
<p>
<b>Example:</b> <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>log</mi>
  <mo>&#x2061;<!-- ⁡ --></mo>
  <mo stretchy="false">(</mo>
  <mi>N</mi>
  <mo stretchy="false">)</mo>
  <mo>+</mo>
  <mn>1</mn>
  <mo>&#x223C;<!-- ∼ --></mo>
  <mi>log</mi>
  <mo>&#x2061;<!-- ⁡ --></mo>
  <mo stretchy="false">(</mo>
  <mi>N</mi>
  <mo stretchy="false">)</mo>
</math>
</p>
<p>
<b>Technical Definition.</b> We say <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>f</mi>
  <mo stretchy="false">(</mo>
  <mi>x</mi>
  <mo stretchy="false">)</mo>
  <mo>&#x223C;<!-- ∼ --></mo>
  <mi>g</mi>
  <mo stretchy="false">(</mo>
  <mi>x</mi>
  <mo stretchy="false">)</mo>
</math>
iff <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mstyle displaystyle="true">
    <munder>
      <mo movablelimits="true">lim</mo>
      <mrow class="MJX-TeXAtom-ORD">
        <mi>x</mi>
        <mo stretchy="false">&#x2192;<!-- → --></mo>
        <mi mathvariant="normal">&#x221E;<!-- ∞ --></mi>
      </mrow>
    </munder>
    <mfrac>
      <mrow>
        <mi>f</mi>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
        <mi>g</mi>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
      </mrow>
    </mfrac>
    <mo>=</mo>
    <mn>1</mn>
  </mstyle>
</math>
</p>
<p>
<b>Exercise.</b> Prove or find a counter-example: if 
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>f</mi>
  <mo stretchy="false">(</mo>
  <mi>x</mi>
  <mo stretchy="false">)</mo>
  <mo>&#x223C;<!-- ∼ --></mo>
  <mi>g</mi>
  <mo stretchy="false">(</mo>
  <mi>x</mi>
  <mo stretchy="false">)</mo>
</math>, then 
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>g</mi>
  <mo stretchy="false">(</mo>
  <mi>x</mi>
  <mo stretchy="false">)</mo>
  <mo>&#x223C;<!-- ∼ --></mo>
  <mi>f</mi>
  <mo stretchy="false">(</mo>
  <mi>x</mi>
  <mo stretchy="false">)</mo>
</math>.
</p>
<p>
<b>Exercise.</b> Prove or find a counter-example: if 
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>f</mi>
  <mo stretchy="false">(</mo>
  <mi>x</mi>
  <mo stretchy="false">)</mo>
  <mo>&#x223C;<!-- ∼ --></mo>
  <mi>g</mi>
  <mo stretchy="false">(</mo>
  <mi>x</mi>
  <mo stretchy="false">)</mo>
</math>
and
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>g</mi>
  <mo stretchy="false">(</mo>
  <mi>x</mi>
  <mo stretchy="false">)</mo>
  <mo>&#x223C;<!-- ∼ --></mo>
  <mi>h</mi>
  <mo stretchy="false">(</mo>
  <mi>x</mi>
  <mo stretchy="false">)</mo>
</math>, then 
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>f</mi>
  <mo stretchy="false">(</mo>
  <mi>x</mi>
  <mo stretchy="false">)</mo>
  <mo>&#x223C;<!-- ∼ --></mo>
  <mi>h</mi>
  <mo stretchy="false">(</mo>
  <mi>x</mi>
  <mo stretchy="false">)</mo>
</math>.
</p>
<p>
<b>Exercise.</b> For any function, is <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>f</mi>
  <mo stretchy="false">(</mo>
  <mi>x</mi>
  <mo stretchy="false">)</mo>
  <mo>&#x223C;<!-- ∼ --></mo>
  <mi>f</mi>
  <mo stretchy="false">(</mo>
  <mi>x</mi>
  <mo stretchy="false">)</mo>
</math>
[tricky: what if f is zero at some point? Or if f(x) = 0?]
</p>
<p>
<b>Remark.</b>
We introduced the tilde notation to approximate the complexity for our
algorithms. Turing said we should just count the most expensive
operations, rather than every operation. So basically, we suppose
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mi>T</mi>
  <mo stretchy="false">(</mo>
  <mi>N</mi>
  <mo stretchy="false">)</mo>
  <mo>&#x223C;<!-- ∼ --></mo>
  <munder>
    <mo movablelimits="true">max</mo>
    <mrow class="MJX-TeXAtom-ORD">
      <mtext>op.</mtext>
    </mrow>
  </munder>
  <mrow>
    <mo>{</mo>
    <mrow>
      <mo>(</mo>
      <mtable rowspacing="4pt" columnspacing="1em">
        <mtr>
          <mtd>
            <mtext>cost</mtext>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mtext>of op.</mtext>
          </mtd>
        </mtr>
      </mtable>
      <mo>)</mo>
    </mrow>
    <mrow>
      <mo>(</mo>
      <mtable rowspacing="4pt" columnspacing="1em">
        <mtr>
          <mtd>
            <mtext>frequency</mtext>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mtext>&#xA0;of op.</mtext>
          </mtd>
        </mtr>
      </mtable>
      <mo>)</mo>
    </mrow>
    <mo>}</mo>
  </mrow>
</math>
as our approximation. Turing's full quote:
<blockquote>
It is convenient to have a measure of the amount of work involved in
a computing process, even though it be a very crude one. We may count
up the number of times that various elementary operations are applied in
the whole process and then give them various weights. We might, for
instance, count the number of additions, subtractions, multiplications,
divisions, recordings of numbers, and extractions of figures from tables.
In the case of computing with matrices most of the work consists of
multiplications and writing down numbers, and we shall therefore only
attempt to count the number of multiplications and recordings.
</blockquote>
From his
paper "<a href="http://qjmam.oxfordjournals.org/content/1/1/287.full.pdf">Round-Off
  Errors in Matrix Processes</a>".
(End of Remark)
</p>
<h3>Example: 2-Sum Problem Revisited</h3>
<p>
Taking Turing's advice, we see 
<ul>
<li><code>N+2~N</code> variable declarations and initializations;</li>
<li><code>(N+1)(N+2)/2~N<sup>2</sup>/2</code> integer comparisons;</li>
<li><code>N(N-1)/2~N<sup>2</sup>/2</code> equality comparisons;</li>
<li><code>N(N-1)~N<sup>2</sup></code> array accesses; and</li>
<li><code>k~N<sup>2</sup>/2</code> increment operations.</li>
</ul>
The main cost is the <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mrow>
      <mo>(</mo>
      <mfrac linethickness="0">
        <mi>N</mi>
        <mn>2</mn>
      </mfrac>
      <mo>)</mo>
    </mrow>
  </mrow>
</math> sum then comparisons. If we generalize to the 3-sum problem, the
cost would be <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mrow>
      <mo>(</mo>
      <mfrac linethickness="0">
        <mi>N</mi>
        <mn>3</mn>
      </mfrac>
      <mo>)</mo>
    </mrow>
  </mrow>
</math>
sum comparisons.</p>
<p>
<b>Bottom line:</b> We will use the tilde approximation for runtimes,
and the runtime for the 3-sum problem is <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>T</mi>
  <mo stretchy="false">(</mo>
  <mi>N</mi>
  <mo stretchy="false">)</mo>
  <mo>&#x223C;<!-- ∼ --></mo>
  <msup>
    <mi>N</mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mn>3</mn>
    </mrow>
  </msup>
</math>
</p>
</section>
<section>
<h2>Order of Growth Classification</h2>
<p>
We want to know what <i>T(N)</i> looks like when plotted. We really have
a limited choice, programmers only care about the set: {1, log(<i>N</i>),
<i>N</i>, <i>N</i>&middot;log(<i>N</i>), <i>N</i><sup>2</sup>, <i>N</i><sup>3</sup>,
2<sup><i>N</i></sup>}. That's it!
</p>
</section>
<footer>
<a href="./index.html">Up</a> &mdash;
<a href="../../index.html">Home</a>
</footer>
</article>
</body>
</html>
